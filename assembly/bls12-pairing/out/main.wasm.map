{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","websnark_bls12.ts","main.ts","~lib/arraybuffer.ts","~lib/rt/stub.ts","~lib/memory.ts","~lib/util/memory.ts"],"names":[],"mappings":"gnBKcM,EAAY,AADA,AADE,IACoB,QAIhC,AAAY,EAFE,AAAC,AAAC,EAAY,GAAY,KAAU,KAAa,aAEpC,KACzB,AAAY,IAAe,SAG1B,SAML,EAAO,WAGK,AAFN,EAAS,KAEG,AADL,AAAW,AAAC,EAAO,GAAW,kBAG/C,AADY,AAAkB,EAAM,KACrB,KACJ,EAAe,KAC1B,EAAa,KACb,EAAe,eE0KT,ADzLW,KC0LL,EAAM,KACN,EAAO,GAAI,GAAG,KACpB,EAAK,KAEC,EAAO,GAAG,KACV,EAAO,GAAG,KACV,EAAO,KAAI,GAAG,KACd,EAAW,GAAG,KACpB,EAAK,KACC,EAAO,GAAG,KACV,EAAO,GAAI,GAAG,KACpB,EAAK,KAKT,EAAK,AAFU,EAAC,GAAO,QAQZ,AAPX,EAAQ,KAOS,KACN,AAAO,AANlB,EAAK,KAMM,GAAW,GAAG,KACrB,EAAK,KACE,EAAO,GAAG,KACV,EAAO,GAAG,KACV,EAAO,KAAI,GAAI,KACf,EAAW,GAAG,KACrB,EAAK,KACE,EAAO,GAAI,KACX,EAAO,GAAI,KACX,EAAO,GAAI,KACX,EAAO,GAAI,KACX,EAAO,KAAI,GAAI,KACf,EAAW,GAAI,KACf,EAAW,GAAI,KACf,EAAW,GAAI,KAIlB,AADJ,AAAM,EAAO,GAAb,KACJ,KACA,EAAK,OAIE,EAAK,KACC,EAAM,KACN,EAAO,GAAG,KACV,EAAO,GAAI,KACX,EAAO,GAAI,KACtB,EAAK,KACL,EAAQ,eH9MN,EAAc,WAEN,AADC,AAAQ,MACE,YDrBN,AADG,AAAgB,AADjB,QAEwB,EAAG,IAI1B,AAAgB,MAChB,AAAgB,MAChB,AAAgB,MAEvB,EAA0B,EAA2B,KAAI,IACzD,EAA0B,EAA+B,IACzD,EAA0B,EAA0B,IAGxD,MAAG,EAAE,OAEC,EAA0B,EAA0B,IACpD,EAA0B,EAA0B,IACpD,EAA0B,EAA0B,IAEpD,EAA0B,EAA0B,IACpD,EAA0B,EAA0B,IACpD,EAA0B,EAA0B,IAEpD,EAA0B,EAA0B,IACpD,EAA0B,EAA0B,IACpD,EAA0B,EAA0B,IAEpD,EAA0B,EAA0B,IACpD,EAA0B,EAA0B,IACpD,EAA0B,EAA0B,IAhB9C,WAoBA","sourceRoot":"assemblyscript:///","sourceContents":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                           GC info                             │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                          runtime id                           │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                         runtime size                          │ -4\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                              ...                              │ ref\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize; // WASM64 needs adaption\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags;\n  /** Base class id or `0` if none. */\n  base: u32;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `Set`. */\n  SET = 1 << 2,\n  /** Type is a `Map`. */\n  MAP = 1 << 3,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 4,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 5,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 6,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 7,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 8,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 9,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 10,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 11,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 12,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 13,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 14,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 15,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 16,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 17,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 18,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 19,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 20,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 21,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 22\n}\n","\n\n/**\n* to call a wasm function defined outside of AS from within AS, I guess\n* we have declare it as an import. the function won't actually be an imported\n* host function, because in gulpfile.js we splice the wat code and paste module-funcs.wat\n* into the AssemblyScript output main.wat.\n* then the external function will be declared twice (once as an import statement\n* generated by AS, and a second time as the function def/wat code pasted in).\n* so to make it valid again, gulpfile.js will find and delete the import statement\n* put there by AS.\n*/\n\n\nbls12_g1m_toMontgomery, bls12_g1m_toMontgomery, bls12_g2m_toMontgomery, bls12_g2m_timesScalar, bls12_g1m_timesScalar, bls12_g1m_affine, bls12_g1m_neg, bls12_f1m_add, bls12_ftm_one, bls12_pairingEq2, bls12_pairing \n\n//   (func $g1m_toMontgomery (export \"g1m_toMontgomery\")  (param $p0 i32) (param $p1 i32)\n@external(\"watimports\", \"$g1m_toMontgomery\")\nexport declare function bls12_g1m_toMontgomery(input: i32, output: i32): void;\n\n@external(\"watimports\", \"$g1m_fromMontgomery\")\nexport declare function bls12_g1m_fromMontgomery(input: i32, output: i32): void;\n\n//   (func $g2m_toMontgomery (export \"g2m_toMontgomery\")  (param $p0 i32) (param $p1 i32)\n@external(\"watimports\", \"$g2m_toMontgomery\")\nexport declare function bls12_g2m_toMontgomery(input: i32, output: i32): void;\n\n@external(\"watimports\", \"$g2m_affine\")\nexport declare function bls12_g2m_affine(input: i32, output: i32): void;\n\n@external(\"watimports\", \"$g1m_affine\")\nexport declare function bls12_g1m_affine(input: i32, output: i32): void;\n\n//  (func $g1m_neg (export \"g1m_neg\") (type $t0) (param $p0 i32) (param $p1 i32)\n@external(\"watimports\", \"$g1m_neg\")\nexport declare function bls12_g1m_neg(input: i32, output: i32): void;\n\n//  (func $g1m_neg (export \"g1m_neg\") (type $t0) (param $p0 i32) (param $p1 i32)\n@external(\"watimports\", \"$f1m_add\")\nexport declare function bls12_f1m_add(a: i32, b: i32, output: i32): void;\n\n\n//  (func $g1m_timesScalar (export \"g1m_timesScalar\") (type $t8) (param $p0 i32) (param $p1 i32) (param $p2 i32) (param $p3 i32)\n@external(\"watimports\", \"$g1m_timesScalar\")\nexport declare function bls12_g1m_timesScalar(p0: i32, p1: i32, p2: i32, p3: i32): void;\n\n@external(\"watimports\", \"$g2m_timesScalar\")\nexport declare function bls12_g2m_timesScalar(p0: i32, p1: i32, p2: i32, p3: i32): void;\n\n//   (func $ftm_one (export \"ftm_one\") (type $t1) (param $p0 i32)\n@external(\"watimports\", \"$ftm_one\")\nexport declare function bls12_ftm_one(p0: i32): void;\n\n//   (func $bn128_pairingEq2 (export \"bn128_pairingEq2\") (type $t10) (param $p0 i32) (param $p1 i32) (param $p2 i32) (param $p3 i32) (param $p4 i32) (result i32)\n@external(\"watimports\", \"$bls12_pairingEq2\")\nexport declare function bls12_pairingEq2(p0: i32, p1: i32, p2: i32, p3: i32, p4: i32): i32;\n\n@external(\"watimports\", \"$bls12_pairing\")\nexport declare function bls12_pairing(p0: i32, p1: i32, p2: i32): void;\n","import { bls12_g1m_toMontgomery, bls12_g2m_toMontgomery, bls12_g2m_timesScalar, bls12_g2m_affine, bls12_g1m_fromMontgomery, bls12_g1m_timesScalar, bls12_g1m_affine, bls12_g1m_neg, bls12_f1m_add, bls12_ftm_one, bls12_pairingEq2, bls12_pairing } from \"./websnark_bls12\";\n\n//@external(\"env\", \"debug_printMemHex\")\n//export declare function debug_mem(pos: i32, len: i32): void;\n\n//@external(\"env\", \"debug_print32\")\n//export declare function debug_print32(pos: i32): void;\n\n//@external(\"env\", \"debug_print48\")\n//export declare function debug_print48(pos: i32): void;\n\n@external(\"env\", \"eth2_blockDataSize\")\nexport declare function eth2_blockDataSize(): i32;\n\n//$main/bignum_f1m_add\n@external(\"env\", \"bignum_f1m_add\")\nexport declare function bignum_f1m_add(a: i32, b: i32, out: i32): void;\n\n\n@external(\"env\", \"eth2_blockDataCopy\")\nexport declare function eth2_blockDataCopy(outputOffset: i32, srcOffset: i32, length: i32): void;\n\n@external(\"env\", \"eth2_loadPreStateRoot\")\nexport declare function eth2_loadPreStateRoot(offset: i32): void;\n\n@external(\"env\", \"eth2_savePostStateRoot\")\nexport declare function eth2_savePostStateRoot(offset: i32): void;\n\n\nexport function main(): i32 {\n\n  let input_data_len = eth2_blockDataSize();\n  let input_data_buff = new ArrayBuffer(input_data_len);\n  eth2_blockDataCopy(input_data_buff as usize, 0, input_data_len);\n\n  const SIZE_F = 48;\n\n  let f1m_add_result1 = new ArrayBuffer(SIZE_F);\n  let f1m_add_result2 = new ArrayBuffer(SIZE_F);\n  let f1m_add_result3 = new ArrayBuffer(SIZE_F);\n\n  bignum_f1m_add(input_data_buff as usize, input_data_buff as usize + 48, f1m_add_result1 as usize);\n  bignum_f1m_add(f1m_add_result1 as usize, input_data_buff as usize + 48, f1m_add_result2 as usize);\n  bignum_f1m_add(f1m_add_result1 as usize, f1m_add_result2 as usize, f1m_add_result3 as usize);\n\n\n  for (let i=1; i<10001; i++) {\n    // 120000 calls\n    bignum_f1m_add(f1m_add_result3 as usize, f1m_add_result2 as usize, f1m_add_result1 as usize);\n    bignum_f1m_add(f1m_add_result1 as usize, f1m_add_result3 as usize, f1m_add_result2 as usize);\n    bignum_f1m_add(f1m_add_result1 as usize, f1m_add_result2 as usize, f1m_add_result3 as usize);\n\n    bignum_f1m_add(f1m_add_result3 as usize, f1m_add_result2 as usize, f1m_add_result1 as usize);\n    bignum_f1m_add(f1m_add_result1 as usize, f1m_add_result3 as usize, f1m_add_result2 as usize);\n    bignum_f1m_add(f1m_add_result1 as usize, f1m_add_result2 as usize, f1m_add_result3 as usize);\n\n    bignum_f1m_add(f1m_add_result3 as usize, f1m_add_result2 as usize, f1m_add_result1 as usize);\n    bignum_f1m_add(f1m_add_result1 as usize, f1m_add_result3 as usize, f1m_add_result2 as usize);\n    bignum_f1m_add(f1m_add_result1 as usize, f1m_add_result2 as usize, f1m_add_result3 as usize);\n\n    bignum_f1m_add(f1m_add_result3 as usize, f1m_add_result2 as usize, f1m_add_result1 as usize);\n    bignum_f1m_add(f1m_add_result1 as usize, f1m_add_result3 as usize, f1m_add_result2 as usize);\n    bignum_f1m_add(f1m_add_result1 as usize, f1m_add_result2 as usize, f1m_add_result3 as usize);\n  }\n\n\n  eth2_savePostStateRoot(f1m_add_result3 as usize);\n\n\n  //bls12.instance.exports.g1m_timesScalar(p1, s_reduced, n8, g1_mul_result);\n\n  // 0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb\n  //let g1_x = Uint8Array.wrap(input_data_buff, 0, 48);\n\n  // 0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1\n  //let g1_y = Uint8Array.wrap(input_data_buff, 48, 96);\n\n  // 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\n  // 0x010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n\n  // G1 point is 144 bytes\n  /*\n  let g1_gen = Uint8Array.wrap(input_data_buff, 0, 144);\n  \n  bls12_g1m_toMontgomery((g1_gen.buffer as usize) + g1_gen.byteOffset, (g1_gen.buffer as usize) + g1_gen.byteOffset);\n  */\n\n  /*  ** test toMontgomery */\n  //eth2_savePostStateRoot((g1_gen.buffer as usize) + g1_gen.byteOffset);\n  // should return 160c53fd9087b35cf5ff769967fc1778c1a13b14c7954f1547e7d0f3cd6aaef040f4db21cc6eceed75fb0b9e417701127122e70cd593acba8efd18791a63228cce250757135f59dd945140502958ac51c05900ad3f8c1c0e6aa20850fc3ebc0bfdff02000000097602000cc40b00f4ebba58c7535798485f455752705358ce776dec56a2971a075c93e480fac35ef615\n\n\n\n  /*****  pairing test **/\n  // G2 point is 288 bytes\n  /*\n  let g2_gen = Uint8Array.wrap(input_data_buff, 144, 288);\n  bls12_g2m_toMontgomery((g2_gen.buffer as usize) + g2_gen.byteOffset, (g2_gen.buffer as usize) + g2_gen.byteOffset);\n\n  let scalar_37 = Array.create<u8>(8);\n  //scalar_arr = [42, 0, 0, 0, 0, 0, 0, 0];\n  scalar_37 = [37, 0, 0, 0, 0, 0, 0, 0];\n\n  let scalar_27 = Array.create<u8>(8);\n  scalar_27 = [27, 0, 0, 0, 0, 0, 0, 0];\n\n  let scalar_999 = Array.create<u8>(8);\n  // 0x03e7\n  scalar_999 = [231, 3, 0, 0, 0, 0, 0, 0];\n\n\n\n  let g1_times_37 = new ArrayBuffer(SIZE_F*3);\n  let g1_times_999 = new ArrayBuffer(SIZE_F*3);\n\n  bls12_g1m_timesScalar((g1_gen.buffer as usize) + g1_gen.byteOffset, (scalar_37.buffer as usize), 2, g1_times_37 as usize);\n  bls12_g1m_affine(g1_times_37 as usize, g1_times_37 as usize);\n\n  bls12_g1m_timesScalar((g1_gen.buffer as usize) + g1_gen.byteOffset, (scalar_999.buffer as usize), 2, g1_times_999 as usize);\n  bls12_g1m_affine(g1_times_999 as usize, g1_times_999 as usize);\n\n  bls12_g1m_neg(g1_times_999 as usize, g1_times_999 as usize);\n\n  let g2_times_27 = new ArrayBuffer(SIZE_F*6);\n\n  bls12_g2m_timesScalar((g2_gen.buffer as usize) + g2_gen.byteOffset, (scalar_27.buffer as usize), 2, g2_times_27 as usize);\n  bls12_g2m_affine(g2_times_27 as usize, g2_times_27 as usize);\n\n\n  let pFq12_result = new ArrayBuffer(SIZE_F*12);\n  bls12_pairing(g1_times_37 as usize, g2_times_27 as usize, pFq12_result as usize);\n  eth2_savePostStateRoot(pFq12_result as usize);\n  */\n\n  /*\n  let pFq12One = new ArrayBuffer(SIZE_F*12);\n  bls12_ftm_one(pFq12One as usize);\n  //eth2_savePostStateRoot(pFq12One as usize + 144);\n\n\n  let pairingEq2_result = bls12_pairingEq2(g1_times_37 as usize, g2_times_27 as usize, g1_times_999 as usize, (g2_gen.buffer as usize) + g2_gen.byteOffset, pFq12One as usize);\n\n  let return_buf = new Array<u32>(32);\n  return_buf[0] = pairingEq2_result;\n  eth2_savePostStateRoot(return_buf.buffer as usize);\n  */\n\n  /*****/\n\n\n\n\n  /*\n  //**** test g1_gen * 42\n  let scalar_42 = Array.create<u8>(8);\n  scalar_42 = [42, 0, 0, 0, 0, 0, 0, 0];\n\n  let pG1_mul_result = new ArrayBuffer(SIZE_F*3);\n\n  bls12_g1m_timesScalar((g1_gen.buffer as usize) + g1_gen.byteOffset, (scalar_42.buffer as usize), 8, pG1_mul_result as usize);\n\n  let pG1_mul_affine = new ArrayBuffer(SIZE_F*3);\n  bls12_g1m_affine(pG1_mul_result as usize, pG1_mul_affine as usize);\n  bls12_g1m_fromMontgomery(pG1_mul_affine as usize, pG1_mul_affine as usize);\n\n  //eth2_savePostStateRoot((pG1_mul_affine as usize));\n  //eth2_savePostStateRoot((pG1_mul_affine as usize) + 16);\n  */\n\n\n  /*\n  let proof_a = Uint8Array.wrap(input_data_buff, 0, 96);\n  // at offset 96\n\n  let vk_a = Uint8Array.wrap(input_data_buff, 96, 192);\n  // at offset 288\n\n  let proof_ap = Uint8Array.wrap(input_data_buff, 288, 96);\n  // at offset 384\n\n  let p2 = Uint8Array.wrap(input_data_buff, 384, 192);\n  // at offset 576 - end of data\n\n\n  let pProofA = new ArrayBuffer(SIZE_F*3);\n  // bn128.instance.exports.g1m_toMontgomery(pProofA, pProofA)\n  bn128_g1m_toMontgomery((proof_a.buffer as usize) + proof_a.byteOffset, pProofA as usize);\n\n  let pVKA = new ArrayBuffer(SIZE_F*6);\n  // bn128.instance.exports.g2m_toMontgomery(pVKA, pVKA);\n  bn128_g2m_toMontgomery((vk_a.buffer as usize) + vk_a.byteOffset, pVKA as usize);\n\n\n\n  let pProof_a_p_neg = new ArrayBuffer(SIZE_F*3);\n  bn128_g1m_neg((proof_ap.buffer as usize) + proof_ap.byteOffset, pProof_a_p_neg as usize);\n  bn128_g1m_toMontgomery(pProof_a_p_neg as usize, pProof_a_p_neg as usize);\n\n  //bn128.setG1(pProof_a_p, proof_a_p) // same as setG1Affine\n  //bn128.instance.exports.g1m_neg(pProof_a_p, pProof_a_p_neg)\n  //bn128.instance.exports.g1m_toMontgomery(pProof_a_p_neg, pProof_a_p_neg)\n\n\n  let pP2 = new ArrayBuffer(SIZE_F*6);\n  bn128_g2m_toMontgomery((p2.buffer as usize) + p2.byteOffset, pP2 as usize);\n\n\n  //let pFq12One = bn128.alloc(SIZE_F * 12);\n  //bn128.instance.exports.ftm_one(pFq12One);\n\n\n  let pFq12One = new ArrayBuffer(SIZE_F*12);\n  bn128_ftm_one(pFq12One as usize);\n\n  //const pairingEq2_result = bn128.instance.exports.bn128_pairingEq2(pProofA, pVKA, pProof_a_p_neg, pP2, pFq12One);\n\n  //let pairingEq2_result = new \n  let pairingEq2_result = bn128_pairingEq2(pProofA as usize, pVKA as usize, pProof_a_p_neg as usize, pP2 as usize, pFq12One as usize);\n\n  //let return_buf = Array.create<u32>(2);\n  let return_buf = new Array<u32>(2);\n  return_buf[0] = pairingEq2_result;\n\n  //secp_g1m_timesScalar(r2_mont_form as usize, (sig_s_le.buffer as usize) + sig_s_le.byteOffset, 32, s_times_r2_result as usize);\n\n  //eth2_savePostStateRoot(pairingEq2_result as usize);\n  eth2_savePostStateRoot(return_buf.buffer as usize);\n  */\n\n  return 1;\n}\n\n\n\n\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK, BLOCK_MAXSIZE, BLOCK_OVERHEAD } from \"./rt/common\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  get length(): i32 {\n    ERROR(\"missing implementation: subclasses must implement ArrayBufferView#length\");\n    return unreachable();\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = __alloc(length = length << alignLog2, idof<ArrayBuffer>());\n    memory.fill(buffer, 0, <usize>length);\n    this.buffer = changetype<ArrayBuffer>(buffer); // retains\n    this.dataStart = buffer;\n    this.byteLength = length;\n  }\n}\n\n@sealed export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (value) {\n      if (value instanceof Int8Array) return true;\n      if (value instanceof Uint8Array) return true;\n      if (value instanceof Uint8ClampedArray) return true;\n      if (value instanceof Int16Array) return true;\n      if (value instanceof Uint16Array) return true;\n      if (value instanceof Int32Array) return true;\n      if (value instanceof Uint32Array) return true;\n      if (value instanceof Int64Array) return true;\n      if (value instanceof Uint64Array) return true;\n      if (value instanceof Float32Array) return true;\n      if (value instanceof Float64Array) return true;\n      if (value instanceof DataView) return true;\n    }\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = __alloc(<usize>length, idof<ArrayBuffer>());\n    memory.fill(buffer, 0, <usize>length);\n    return changetype<ArrayBuffer>(buffer); // retains\n  }\n\n  get byteLength(): i32 {\n    return changetype<BLOCK>(changetype<usize>(this) - BLOCK_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    var length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    var outSize = <usize>max(end - begin, 0);\n    var out = __alloc(outSize, idof<ArrayBuffer>());\n    memory.copy(out, changetype<usize>(this) + <usize>begin, outSize);\n    return changetype<ArrayBuffer>(out); // retains\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","import { AL_MASK, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE, AL_SIZE, DEBUG } from \"rt/common\";\n\n// @ts-ignore: decorator\n@lazy\nvar startOffset: usize = (__heap_base + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@lazy\nvar offset: usize = startOffset;\n\nfunction maybeGrowMemory(newOffset: usize): void {\n  // assumes newOffset is aligned\n  var pagesBefore = memory.size();\n  var maxOffset = <usize>pagesBefore << 16;\n  if (newOffset > maxOffset) {\n    let pagesNeeded = ((newOffset - maxOffset + 0xffff) & ~0xffff) >>> 16;\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (memory.grow(pagesWanted) < 0) {\n      if (memory.grow(pagesNeeded) < 0) unreachable(); // out of memory\n    }\n  }\n  offset = newOffset;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __alloc(size: usize, id: u32): usize {\n  if (size > BLOCK_MAXSIZE) unreachable();\n  var ptr = offset + BLOCK_OVERHEAD;\n  var actualSize = max<usize>((size + AL_MASK) & ~AL_MASK, AL_SIZE);\n  maybeGrowMemory(ptr + actualSize);\n  var block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  block.mmInfo = actualSize;\n  if (DEBUG) block.gcInfo = -1;\n  block.rtId = id;\n  block.rtSize = size;\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __realloc(ptr: usize, size: usize): usize {\n  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned\n  var block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  var actualSize = block.mmInfo;\n  if (DEBUG) assert(block.gcInfo == -1);\n  if (size > actualSize) {\n    if (ptr + actualSize == offset) { // last block: grow\n      if (size > BLOCK_MAXSIZE) unreachable();\n      actualSize = (size + AL_MASK) & ~AL_MASK;\n      maybeGrowMemory(ptr + actualSize);\n      block.mmInfo = actualSize;\n    } else { // copy to new block at least double the size\n      actualSize = max<usize>((size + AL_MASK) & ~AL_MASK, actualSize << 1);\n      let newPtr = __alloc(actualSize, block.rtId);\n      memory.copy(newPtr, ptr, block.rtSize);\n      block = changetype<BLOCK>((ptr = newPtr) - BLOCK_OVERHEAD);\n    }\n  } else if (ptr + actualSize == offset) { // last block: shrink\n    actualSize = (size + AL_MASK) & ~AL_MASK;\n    offset = ptr + actualSize;\n    block.mmInfo = actualSize;\n  }\n  block.rtSize = size;\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __free(ptr: usize): void {\n  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned\n  var block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  if (DEBUG) assert(block.gcInfo == -1);\n  if (ptr + block.mmInfo == offset) { // last block: discard\n    offset = changetype<usize>(block);\n  }\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nfunction __reset(): void { // special\n  offset = startOffset;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __retain(ref: usize): usize {\n  return ref;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __release(ref: usize): void {\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ref: usize, cookie: u32): void {\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n}\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    var index: usize = 0;\n    var total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    let w: u32, x: u32;\n\n    // copy 1 byte each until src is aligned to 4 bytes\n    while (n && (src & 3)) {\n      store<u8>(dest++, load<u8>(src++));\n      n--;\n    }\n\n    // if dst is aligned to 4 bytes as well, copy 4 bytes each\n    if ((dest & 3) == 0) {\n      while (n >= 16) {\n        store<u32>(dest     , load<u32>(src     ));\n        store<u32>(dest +  4, load<u32>(src +  4));\n        store<u32>(dest +  8, load<u32>(src +  8));\n        store<u32>(dest + 12, load<u32>(src + 12));\n        src += 16; dest += 16; n -= 16;\n      }\n      if (n & 8) {\n        store<u32>(dest    , load<u32>(src    ));\n        store<u32>(dest + 4, load<u32>(src + 4));\n        dest += 8; src += 8;\n      }\n      if (n & 4) {\n        store<u32>(dest, load<u32>(src));\n        dest += 4; src += 4;\n      }\n      if (n & 2) { // drop to 2 bytes each\n        store<u16>(dest, load<u16>(src));\n        dest += 2; src += 2;\n      }\n      if (n & 1) { // drop to 1 byte\n        store<u8>(dest++, load<u8>(src++));\n      }\n      return;\n    }\n\n    // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n    // doing shifts if faster when copying enough bytes (here: 32 or more)\n    if (n >= 32) {\n      switch (dest & 3) {\n        // known to be != 0\n        case 1: {\n          w = load<u32>(src);\n          store<u8>(dest++, load<u8>(src++));\n          store<u8>(dest++, load<u8>(src++));\n          store<u8>(dest++, load<u8>(src++));\n          n -= 3;\n          while (n >= 17) {\n            x = load<u32>(src + 1);\n            store<u32>(dest, w >> 24 | x << 8);\n            w = load<u32>(src + 5);\n            store<u32>(dest + 4, x >> 24 | w << 8);\n            x = load<u32>(src + 9);\n            store<u32>(dest + 8, w >> 24 | x << 8);\n            w = load<u32>(src + 13);\n            store<u32>(dest + 12, x >> 24 | w << 8);\n            src += 16; dest += 16; n -= 16;\n          }\n          break;\n        }\n        case 2: {\n          w = load<u32>(src);\n          store<u8>(dest++, load<u8>(src++));\n          store<u8>(dest++, load<u8>(src++));\n          n -= 2;\n          while (n >= 18) {\n            x = load<u32>(src + 2);\n            store<u32>(dest, w >> 16 | x << 16);\n            w = load<u32>(src + 6);\n            store<u32>(dest + 4, x >> 16 | w << 16);\n            x = load<u32>(src + 10);\n            store<u32>(dest + 8, w >> 16 | x << 16);\n            w = load<u32>(src + 14);\n            store<u32>(dest + 12, x >> 16 | w << 16);\n            src += 16; dest += 16; n -= 16;\n          }\n          break;\n        }\n        case 3: {\n          w = load<u32>(src);\n          store<u8>(dest++, load<u8>(src++));\n          n -= 1;\n          while (n >= 19) {\n            x = load<u32>(src + 3);\n            store<u32>(dest, w >> 8 | x << 24);\n            w = load<u32>(src + 7);\n            store<u32>(dest + 4, x >> 8 | w << 24);\n            x = load<u32>(src + 11);\n            store<u32>(dest + 8, w >> 8 | x << 24);\n            w = load<u32>(src + 15);\n            store<u32>(dest + 12, x >> 8 | w << 24);\n            src += 16; dest += 16; n -= 16;\n          }\n          break;\n        }\n      }\n    }\n\n    // copy remaining bytes one by one\n    if (n & 16) {\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n    }\n    if (n & 8) {\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n    }\n    if (n & 4) {\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n    }\n    if (n & 2) {\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n    }\n    if (n & 1) {\n      store<u8>(dest++, load<u8>(src++));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src + n <= dest || dest + n <= src) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if ((src & 7) == (dest & 7)) {\n      while (dest & 7) {\n        if (!n) return;\n        --n;\n        store<u8>(dest++, load<u8>(src++));\n      }\n      while (n >= 8) {\n        store<u64>(dest, load<u64>(src));\n        n    -= 8;\n        dest += 8;\n        src  += 8;\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if ((src & 7) == (dest & 7)) {\n      while ((dest + n) & 7) {\n        if (!n) return;\n        store<u8>(dest + --n, load<u8>(src + n));\n      }\n      while (n >= 8) {\n        n -= 8;\n        store<u64>(dest + n, load<u64>(src + n));\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    store<u8>(dest, c);\n    store<u8>(dest + n - 1, c);\n    if (n <= 2) return;\n\n    store<u8>(dest + 1, c);\n    store<u8>(dest + 2, c);\n    store<u8>(dest + n - 2, c);\n    store<u8>(dest + n - 3, c);\n    if (n <= 6) return;\n    store<u8>(dest + 3, c);\n    store<u8>(dest + n - 4, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    store<u32>(dest, c32);\n    store<u32>(dest + n - 4, c32);\n    if (n <= 8) return;\n    store<u32>(dest + 4, c32);\n    store<u32>(dest + 8, c32);\n    store<u32>(dest + n - 12, c32);\n    store<u32>(dest + n - 8, c32);\n    if (n <= 24) return;\n    store<u32>(dest + 12, c32);\n    store<u32>(dest + 16, c32);\n    store<u32>(dest + 20, c32);\n    store<u32>(dest + 24, c32);\n    store<u32>(dest + n - 28, c32);\n    store<u32>(dest + n - 24, c32);\n    store<u32>(dest + n - 20, c32);\n    store<u32>(dest + n - 16, c32);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest + 8, c64);\n      store<u64>(dest + 16, c64);\n      store<u64>(dest + 24, c64);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\n  if (vl == vr) return 0;\n  if (ASC_SHRINK_LEVEL < 2) {\n    if ((vl & 7) == (vr & 7)) {\n      while (vl & 7) {\n        if (!n) return 0;\n        let a = <i32>load<u8>(vl);\n        let b = <i32>load<u8>(vr);\n        if (a != b) return a - b;\n        n--; vl++; vr++;\n      }\n      while (n >= 8) {\n        if (load<u64>(vl) != load<u64>(vr)) break;\n        vl += 8;\n        vr += 8;\n        n  -= 8;\n      }\n    }\n  }\n  while (n--) {\n    let a = <i32>load<u8>(vl);\n    let b = <i32>load<u8>(vr);\n    if (a != b) return a - b;\n    vl++; vr++;\n  }\n  return 0;\n}\n"]}