

/**
* to call a wasm function defined outside of AS from within AS, I guess
* we have declare it as an import. the function won't actually be an imported
* host function, because in gulpfile.js we splice the wat code and paste module-funcs.wat
* into the AssemblyScript output main.wat.
* then the external function will be declared twice (once as an import statement
* generated by AS, and a second time as the function def/wat code pasted in).
* so to make it valid again, gulpfile.js will find and delete the import statement
* put there by AS.
*/

//   (func $g1m_toMontgomery (export "g1m_toMontgomery")  (param $p0 i32) (param $p1 i32)
@external("watimports", "$g1m_toMontgomery")
export declare function secp_g1m_toMontgomery(input: i32, output: i32): void;

//   (func $g1m_timesScalar (export "g1m_timesScalar")  (param $p0 i32) (param $p1 i32) (param $p2 i32) (param $p3 i32)
@external("watimports", "$g1m_timesScalar")
export declare function secp_g1m_timesScalar(g1Point: i32, scalarOffset: i32, scalarBitSize: i32, output: i32): void;

//  (func $g1m_add (export "g1m_add")  (param $p0 i32) (param $p1 i32) (param $p2 i32)
@external("watimports", "$g1m_add")
export declare function secp_g1m_add(g1PointA: i32, g1PointB: i32, g1PointResult: i32): void;

//   (func $g1m_affine (export "g1m_affine")  (param $p0 i32) (param $p1 i32)
@external("watimports", "$g1m_affine")
export declare function secp_g1m_affine(input: i32, output: i32): void;

//   (func $g1m_fromMontgomery (export "g1m_fromMontgomery")  (param $p0 i32) (param $p1 i32)
@external("watimports", "$g1m_fromMontgomery")
export declare function secp_g1m_fromMontgomery(input: i32, output: i32): void;

//  (func $fr_inverse (export "fr_inverse")  (param $p0 i32) (param $p1 i32)
@external("watimports", "$fr_inverse")
export declare function secp_fr_inverse(input: i32, output: i32): void;

@external("watimports", "$frm_neg")
export declare function secp_frm_neg(input: i32, output: i32): void;
